{
  "columns": [
    "Unnamed: 0",
    "cwe_id",
    "source",
    "target",
    "project_and_commit_id",
    "cve_id",
    "original_address",
    "time",
    "Unnamed: 0.1",
    "raw_predictions",
    "correctly_predicted"
  ],
  "data": [
    [
      106,
      "CWE-78",
      "CWE-78 R_API char * r_socket_http_post ( const char * url , const char * data , int * code , int * rlen ) { RSocket * s ; bool ssl = r_str_startswith ( url , \"https://\" ) ; char * uri = strdup ( url ) ; if ( ! uri ) { return NULL ; } char * host = strstr ( uri , \"://\" ) ; if ( ! host ) { free ( uri ) ; printf ( \"Invalid<S2SV_blank>URI\" ) ; return NULL ; } host += 3 ; char * port = strchr ( host , ':' ) ; if ( ! port ) { port = ( ssl ) ? \"443\" : \"80\" ; } else { * port ++ = 0 ; } char * path = strchr ( host , '/' ) ; if ( ! path ) { path = \"\" ; } else { * path ++ = 0 ; } s = r_socket_new ( ssl ) ; if ( ! s ) { printf ( \"Cannot<S2SV_blank>create<S2SV_blank>socket\\\\n\" ) ; free ( uri ) ; return NULL ; } if ( ! r_socket_connect_tcp ( s , host , port , 0 ) ) { eprintf ( \"Cannot<S2SV_blank>connect<S2SV_blank>to<S2SV_blank>%s:%s\\\\n\" , host , port ) ; free ( uri ) ; return NULL ; } r_socket_printf ( s , \"POST<S2SV_blank>/%s<S2SV_blank>HTTP/1.0\\\\r\\\\n\" \"User-Agent:<S2SV_blank>radare2<S2SV_blank>\" R2_VERSION \"\\\\r\\\\n\" \"Accept:<S2SV_blank>*/*\\\\r\\\\n\" \"Host:<S2SV_blank>%s\\\\r\\\\n\" \"Content-Length:<S2SV_blank>%i\\\\r\\\\n\" \"Content-Type:<S2SV_blank>application/x-www-form-urlencoded\\\\r\\\\n\" \"\\\\r\\\\n\" , path , host , ( int ) strlen ( data ) ) ; free ( uri ) ; r_socket_write ( s , ( void * ) data , strlen ( data ) ) ; <S2SV_StartBug> return r_socket_http_answer ( s , code , rlen ) ; <S2SV_EndBug> }\n",
      "<S2SV_ModStart> ) ; return socket_http_answer <S2SV_ModEnd> ( s , <S2SV_ModStart> code , rlen , 0\n",
      "radareorg@radare2/04edfa82c1f3fa2bc3621ccdad2f93bdbf00e4f9",
      "CVE-2020-15121",
      "https://github.com/radareorg/radare2/commit/04edfa82c1f3fa2bc3621ccdad2f93bdbf00e4f9",
      "2020-07-20T18:15Z",
      106,
      "<S2SV_ModStart> ) ) ; if (! r_socket_http_answer ( s, code, rlen ) ) { free ( uri ) ; return NULL ; }",
      0
    ],
    [
      236,
      "CWE-78",
      "CWE-78 static char * __filterShell ( const char * arg ) { r_return_val_if_fail ( arg , NULL ) ; char * a = malloc ( strlen ( arg ) + 1 ) ; if ( ! a ) { return NULL ; } char * b = a ; while ( * arg ) { <S2SV_StartBug> switch ( * arg ) { <S2SV_EndBug> case '@' : case '`' : case '|' : case ';' : <S2SV_StartBug> case '\\\\n' : <S2SV_EndBug> break ; default : <S2SV_StartBug> * b ++ = * arg ; <S2SV_EndBug> break ; } arg ++ ; } * b = 0 ; return a ; }\n",
      "<S2SV_ModStart> arg ) { char ch = * arg ; switch ( ch <S2SV_ModEnd> ) { case <S2SV_ModStart> ';' : case '=' : case <S2SV_ModStart> b ++ = ch <S2SV_ModEnd> ; break ;\n",
      "radareorg@radare2/5411543a310a470b1257fb93273cdd6e8dfcb3af",
      "CVE-2019-16718",
      "https://github.com/radareorg/radare2/commit/5411543a310a470b1257fb93273cdd6e8dfcb3af",
      "2019-09-23T14:15Z",
      236,
      "<S2SV_ModStart> arg ) { char ch = * arg ; switch ( ch <S2SV_ModEnd> ) { case <S2SV_ModStart> ';' : case '=' : case <S2SV_ModStart> b ++ = ch <S2SV_ModEnd> ; break ;",
      1
    ],
    [
      1203,
      "CWE-78",
      "CWE-78 static int bin_symbols ( RCore * r , int mode , ut64 laddr , int va , ut64 at , const char * name , bool exponly , const char * args ) { RBinInfo * info = r_bin_get_info ( r -> bin ) ; RList * entries = r_bin_get_entries ( r -> bin ) ; RBinSymbol * symbol ; RBinAddr * entry ; RListIter * iter ; bool firstexp = true ; bool printHere = false ; int i = 0 , lastfs = 's' ; bool bin_demangle = r_config_get_i ( r -> config , \"bin.demangle\" ) ; if ( ! info ) { return 0 ; } if ( args && * args == '.' ) { printHere = true ; } bool is_arm = info && info -> arch && ! strncmp ( info -> arch , \"arm\" , 3 ) ; const char * lang = bin_demangle ? r_config_get ( r -> config , \"bin.lang\" ) : NULL ; RList * symbols = r_bin_get_symbols ( r -> bin ) ; r_spaces_push ( & r -> anal -> meta_spaces , \"bin\" ) ; if ( IS_MODE_JSON ( mode ) && ! printHere ) { r_cons_printf ( \"[\" ) ; } else if ( IS_MODE_SET ( mode ) ) { r_flag_space_set ( r -> flags , R_FLAGS_FS_SYMBOLS ) ; } else if ( ! at && exponly ) { if ( IS_MODE_RAD ( mode ) ) { r_cons_printf ( \"fs<S2SV_blank>exports\\\\n\" ) ; } else if ( IS_MODE_NORMAL ( mode ) ) { r_cons_printf ( printHere ? \"\" : \"[Exports]\\\\n\" ) ; } } else if ( ! at && ! exponly ) { if ( IS_MODE_RAD ( mode ) ) { r_cons_printf ( \"fs<S2SV_blank>symbols\\\\n\" ) ; } else if ( IS_MODE_NORMAL ( mode ) ) { r_cons_printf ( printHere ? \"\" : \"[Symbols]\\\\n\" ) ; } } if ( IS_MODE_NORMAL ( mode ) ) { r_cons_printf ( \"Num<S2SV_blank>Paddr<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Vaddr<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Bind<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Type<S2SV_blank>Size<S2SV_blank>Name\\\\n\" ) ; } size_t count = 0 ; r_list_foreach ( symbols , iter , symbol ) { if ( ! symbol -> name ) { continue ; } char * r_symbol_name = r_str_escape_utf8 ( symbol -> name , false , true ) ; ut64 addr = compute_addr ( r -> bin , symbol -> paddr , symbol -> vaddr , va ) ; int len = symbol -> size ? symbol -> size : 32 ; SymName sn = { 0 } ; if ( exponly && ! isAnExport ( symbol ) ) { free ( r_symbol_name ) ; continue ; } if ( name && strcmp ( r_symbol_name , name ) ) { free ( r_symbol_name ) ; continue ; } if ( at && ( ! symbol -> size || ! is_in_range ( at , addr , symbol -> size ) ) ) { free ( r_symbol_name ) ; continue ; } if ( ( printHere && ! is_in_range ( r -> offset , symbol -> paddr , len ) ) && ( printHere && ! is_in_range ( r -> offset , addr , len ) ) ) { free ( r_symbol_name ) ; continue ; } count ++ ; snInit ( r , & sn , symbol , lang ) ; if ( IS_MODE_SET ( mode ) && ( is_section_symbol ( symbol ) || is_file_symbol ( symbol ) ) ) { } else if ( IS_MODE_SET ( mode ) && is_special_symbol ( symbol ) ) { if ( is_arm ) { handle_arm_special_symbol ( r , symbol , va ) ; } } else if ( IS_MODE_SET ( mode ) ) { if ( is_arm ) { handle_arm_symbol ( r , symbol , info , va ) ; } select_flag_space ( r , symbol ) ; if ( sn . classname ) { RFlagItem * fi = r_flag_get ( r -> flags , sn . methflag ) ; if ( r -> bin -> prefix ) { char * prname = r_str_newf ( \"%s.%s\" , r -> bin -> prefix , sn . methflag ) ; r_name_filter ( sn . methflag , - 1 ) ; free ( sn . methflag ) ; sn . methflag = prname ; } if ( fi ) { r_flag_item_set_realname ( fi , sn . methname ) ; if ( ( fi -> offset - r -> flags -> base ) == addr ) { r_flag_unset ( r -> flags , fi ) ; } } else { fi = r_flag_set ( r -> flags , sn . methflag , addr , symbol -> size ) ; char * comment = fi -> comment ? strdup ( fi -> comment ) : NULL ; if ( comment ) { r_flag_item_set_comment ( fi , comment ) ; R_FREE ( comment ) ; } } } else { const char * n = sn . demname ? sn . demname : sn . name ; const char * fn = sn . demflag ? sn . demflag : sn . nameflag ; char * fnp = ( r -> bin -> prefix ) ? r_str_newf ( \"%s.%s\" , r -> bin -> prefix , fn ) : strdup ( fn ) ; RFlagItem * fi = r_flag_set ( r -> flags , fnp , addr , symbol -> size ) ; if ( fi ) { r_flag_item_set_realname ( fi , n ) ; fi -> demangled = ( bool ) ( size_t ) sn . demname ; } else { if ( fn ) { eprintf ( \"[Warning]<S2SV_blank>Can\\'t<S2SV_blank>find<S2SV_blank>flag<S2SV_blank>(%s)\\\\n\" , fn ) ; } } free ( fnp ) ; } if ( sn . demname ) { r_meta_add ( r -> anal , R_META_TYPE_COMMENT , addr , symbol -> size , sn . demname ) ; } r_flag_space_pop ( r -> flags ) ; } else if ( IS_MODE_JSON ( mode ) ) { char * str = r_str_escape_utf8_for_json ( r_symbol_name , - 1 ) ; r_cons_printf ( \"%s{\\\\\"name\\\\\":\\\\\"%s\\\\\",\" \"\\\\\"demname\\\\\":\\\\\"%s\\\\\",\" \"\\\\\"flagname\\\\\":\\\\\"%s\\\\\",\" \"\\\\\"ordinal\\\\\":%d,\" \"\\\\\"bind\\\\\":\\\\\"%s\\\\\",\" \"\\\\\"size\\\\\":%d,\" \"\\\\\"type\\\\\":\\\\\"%s\\\\\",\" \"\\\\\"vaddr\\\\\":%\" PFMT64d \",\" \"\\\\\"paddr\\\\\":%\" PFMT64d \"}\" , ( ( exponly && firstexp ) || printHere ) ? \"\" : ( iter -> p ? \",\" : \"\" ) , str , sn . demname ? sn . demname : \"\" , sn . nameflag , symbol -> ordinal , symbol -> bind , ( int ) symbol -> size , symbol -> type , ( ut64 ) addr , ( ut64 ) symbol -> paddr ) ; free ( str ) ; } else if ( IS_MODE_SIMPLE ( mode ) ) { const char * name = sn . demname ? sn . demname : r_symbol_name ; r_cons_printf ( \"0x%08\" PFMT64x \"<S2SV_blank>%d<S2SV_blank>%s\\\\n\" , addr , ( int ) symbol -> size , name ) ; } else if ( IS_MODE_SIMPLEST ( mode ) ) { const char * name = sn . demname ? sn . demname : r_symbol_name ; r_cons_printf ( \"%s\\\\n\" , name ) ; } else if ( IS_MODE_RAD ( mode ) ) { if ( is_special_symbol ( symbol ) ) { goto next ; } RBinFile * binfile ; RBinPlugin * plugin ; const char * name = sn . demname ? sn . demname : r_symbol_name ; if ( ! name ) { goto next ; } if ( ! strncmp ( name , \"imp.\" , 4 ) ) { if ( lastfs != 'i' ) { r_cons_printf ( \"fs<S2SV_blank>imports\\\\n\" ) ; } lastfs = 'i' ; } else { if ( lastfs != 's' ) { const char * fs = exponly ? \"exports\" : \"symbols\" ; r_cons_printf ( \"fs<S2SV_blank>%s\\\\n\" , fs ) ; } lastfs = 's' ; } if ( r -> bin -> prefix || * name ) { char * flagname = construct_symbol_flagname ( \"sym\" , name , MAXFLAG_LEN_DEFAULT ) ; if ( ! flagname ) { goto next ; } r_cons_printf ( \"\\\\\"f<S2SV_blank>%s%s%s<S2SV_blank>%u<S2SV_blank>0x%08\" PFMT64x \"\\\\\"\\\\n\" , r -> bin -> prefix ? r -> bin -> prefix : \"\" , r -> bin -> prefix ? \".\" : \"\" , flagname , symbol -> size , addr ) ; free ( flagname ) ; } binfile = r_bin_cur ( r -> bin ) ; plugin = r_bin_file_cur_plugin ( binfile ) ; if ( plugin && plugin -> name ) { if ( r_str_startswith ( plugin -> name , \"pe\" ) ) { char * module = strdup ( r_symbol_name ) ; char * p = strstr ( module , \".dll_\" ) ; if ( p && strstr ( module , \"imp.\" ) ) { char * symname = __filterShell ( p + 5 ) ; char * m = __filterShell ( module ) ; * p = 0 ; if ( r -> bin -> prefix ) { <S2SV_StartBug> r_cons_printf ( \"k<S2SV_blank>bin/pe/%s/%d=%s.%s\\\\n\" , <S2SV_EndBug> module , symbol -> ordinal , r -> bin -> prefix , symname ) ; } else { <S2SV_StartBug> r_cons_printf ( \"k<S2SV_blank>bin/pe/%s/%d=%s\\\\n\" , <S2SV_EndBug> module , symbol -> ordinal , symname ) ; } free ( symname ) ; free ( m ) ; } free ( module ) ; } } } else { const char * bind = symbol -> bind ? symbol -> bind : \"NONE\" ; const char * type = symbol -> type ? symbol -> type : \"NONE\" ; const char * name = r_str_get ( sn . demname ? sn . demname : r_symbol_name ) ; r_cons_printf ( \"%03u\" , symbol -> ordinal ) ; if ( symbol -> paddr == UT64_MAX ) { r_cons_printf ( \"<S2SV_blank>----------\" ) ; } else { r_cons_printf ( \"<S2SV_blank>0x%08\" PFMT64x , symbol -> paddr ) ; } r_cons_printf ( \"<S2SV_blank>0x%08\" PFMT64x \"<S2SV_blank>%6s<S2SV_blank>%6s<S2SV_blank>%4d%s%s\\\\n\" , addr , bind , type , symbol -> size , * name ? \"<S2SV_blank>\" : \"\" , name ) ; } next : snFini ( & sn ) ; i ++ ; free ( r_symbol_name ) ; if ( exponly && firstexp ) { firstexp = false ; } if ( printHere ) { break ; } } if ( count == 0 && IS_MODE_JSON ( mode ) ) { r_cons_printf ( \"{}\" ) ; } if ( is_arm ) { r_list_foreach ( entries , iter , entry ) { if ( IS_MODE_SET ( mode ) ) { handle_arm_entry ( r , entry , info , va ) ; } } } if ( IS_MODE_JSON ( mode ) && ! printHere ) { r_cons_printf ( \"]\" ) ; } r_spaces_pop ( & r -> anal -> meta_spaces ) ; return true ; }\n",
      "<S2SV_ModStart> { r_cons_printf ( \"\\\\\"k<S2SV_blank>bin/pe/%s/%d=%s.%s\\\\\"\\\\n\" <S2SV_ModEnd> , module , <S2SV_ModStart> { r_cons_printf ( \"\\\\\"k<S2SV_blank>bin/pe/%s/%d=%s\\\\\"\\\\n\" <S2SV_ModEnd> , module ,\n",
      "radareorg@radare2/5411543a310a470b1257fb93273cdd6e8dfcb3af",
      "CVE-2019-16718",
      "https://github.com/radareorg/radare2/commit/5411543a310a470b1257fb93273cdd6e8dfcb3af",
      "2019-09-23T14:15Z",
      1203,
      "<S2SV_ModStart> { r_cons_printf ( \"\\\\n\" ) ; } if ( IS_MODE_RAD ( mode ) ) { r_cons_printf ( \"\\\\nFS <S2SV_blank> exports\\\\n\" ) ; } else if ( IS_MODE_NORMAL ( mode ) ) { r_cons_printf ( \"\\\\nFS <S2SV_blank> symbols\\\\n\" ) ; } else if ( IS_MODE_SET ( mode ) ) { r_flag_space_set ( r -> flags, R_FLAGS_FS_SYMBOLS ) ; } else { r_spaces_push ( & r -> anal -> meta_spaces, \"bin\" ) ; } if (! at &&! exponly ) { if ( IS_MODE_RAD ( mode ) ) { r_cons_printf ( \"\\\\nFS <S2SV_blank> symbols\\\\n\" ) ; } else if ( IS_MODE_NORMAL ( mode ) ) { r_cons_printf ( \"\\\\nFS <S2SV_blank> exports\\\\n\" ) ; } else if ( IS_MODE_NORMAL ( mode ) ) { r_spaces_push ( & r -> anal -> meta_spaces, \"bin\" ) ; }",
      0
    ]
  ]
}